{
    "collab_server" : "",
    "contents" : "#' @keywords internal\n#' @noRd\nis.Adj <- function(A){\n  # 1. size\n  cond1 = ((is.matrix(A))&&(nrow(A)==ncol(A)))\n  # 2. symmetric : bounded\n  cond2 = (sum((A-t(A))^2)<1e-10)\n  # 3. no negative values\n  cond3 = (all((A>=0)))\n  # 4. diagonals are zeros\n  cond4 = (all(diag(A)==0))\n\n  if (cond1&&cond2&&cond3&&cond4){\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n\n## Binary {0,1} adjacency\n#' @keywords internal\n#' @noRd\nis.binAdj <- function(A,sym=TRUE){\n  # 1. size\n  cond1 = ((is.matrix(A))&&(nrow(A)==ncol(A)))\n  # 2. symmetric : bounded\n  if (sym){\n    cond2 = (sum((A-t(A))^2)<1e-10)\n  } else {\n    cond2 = TRUE\n  }\n  # 3. no negative values\n  cond3 = (all((A>=0)))\n  # 4. diagonals are zeros\n  cond4 = (all(diag(A)==0))\n  # 5. all binaries\n  cond5 = all((A==1)||(A==0))\n\n  if (cond1&&cond2&&cond3&&cond4&&cond5){\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n\n#' @keywords internal\n#' @noRd\nis.binAdjvec <- function(vecA,sym=TRUE){\n  # 1. size\n  cond1 = (length(unique(unlist(lapply(vecA,nrow)))==1))\n  # 2. other factors\n  if (sym){\n    symvec = TRUE\n  } else {\n    symvec = FALSE\n  }\n\n  cvec = array(0,c(length(vecA),1))\n  for (i in 1:length(vecA)){\n    if (is.binAdj(vecA[[i]],sym=symvec)){\n      cvec[i] = 1\n    }\n  }\n  if (sum(cvec)==length(cvec)){\n    cond2 = TRUE\n  } else {\n    cond2 = FALSE\n  }\n\n  if (cond1&&cond2){\n    return(TRUE)\n  } else{\n    return(FALSE)\n  }\n}\n\n#' @keywords internal\n#' @noRd\nsum3 <- function(vecA,x,y,z){\n  T = length(vecA)\n  if (is.logical(x)){\n    nx = which(x)\n  } else {\n    nx = length(x)\n  }\n  if (is.logical(y)){\n    ny = which(y)\n  } else {\n    ny = length(y)\n  }\n  res = array(0,c(nx,ny))\n  for (i in 1:length(z)){\n    tgtnum = z[i]\n    res = res+vecA[[tgtnum]][x,y]\n  }\n  return(res)\n}\n\n# Inputs\n#   G : vector list of (n x n) graph\n#   B : vector list of clusters\n# Output - a list containing\n#   H : 3D histogram\n#   P : corresponding probability matrix of (n x n)\n#' @keywords internal\n#' @noRd\nhistogram3D <- function(G,B){\n  # 1. get information about data\n  n  = nrow(G[[1]])\n  nT = length(G)\n  nB = length(B)\n\n  # 2. initialization\n  P = array(0,c(n,n))\n  H = array(0,c(nB,nB))\n\n  # 3. Loop through all the clusters\n  for (ki in 1:nB){\n    for (kj in 1:nB){\n      # 3-1. obtain the indices in cluster ki and kj\n      I = B[[ki]]\n      J = B[[kj]]\n\n      # 3-2. compute 3D histogram\n      H[ki,kj] = sum(sum3(G,I,J,1:nT))/(T*length(I)*length(J))\n\n      # 3-3. loop through the indices in cluster I and J\n      # to compute the corresponding probability matrix\n      for (i1 in 1:length(I)){\n        for (j1 in 1:length(J)){\n          vi = I[i1]\n          vj = J[j1]\n          P[vi,vj] = H[ki,kj]\n        }\n      }\n    }\n  }\n\n  # 4. return output in a list format\n  res = list()\n  res$H = H\n  res$P = P\n  return(res)\n}\n\n#' @keywords internal\n#' @noRd\naux_nbdsmooth <- function(A,N){\n  # definitions\n  D = array(0,c(N,N))\n  A_sq = (A%*%A)/N\n\n  # compute D : dissimilarity\n  for (i in 1:(N-1)){\n    for (j in (i+1):N){\n      val = max(abs(A_sq[i,]-A_sq[j,]))\n      D[i,j] = val\n      D[j,i] = val\n    }\n  }\n\n  # return result\n  return(D)\n}\n\n# gmodel.preset : fast generation -----------------------------------------\n#' @keywords internal\n#' @noRd\naux_preset <- function(vecgrid,n,id){\n  # preparation\n  W = array(0,c(n,n))\n\n  # iteration\n  for (i in 1:n){\n    u = vecgrid[i]\n    for (j in 1:n){\n      v = vecgrid[j]\n      if (id==1){\n        W[i,j] = u*v;\n      } else if (id==2){\n        W[i,j] = exp(-((u**0.7)+(v**0.7)));\n      } else if (id==3){\n        W[i,j] = ((u**2)+(v**2)+sqrt(u)+sqrt(v))/4;\n      } else if (id==4){\n        W[i,j] = (u+v)/2;\n      } else if (id==5){\n        W[i,j] = 1/(1+exp(-10*((u**2)+(v**2))));\n      } else if (id==6){\n        W[i,j] = abs(u-v)\n      } else {\n        maxuv = max(u,v)\n        minuv = min(u,v)\n        if (id==7){\n          W[i,j] = 1/(1+exp(-((maxuv**2)+(minuv**4))));\n        } else if (id==8){\n          W[i,j] = exp(-(maxuv**0.75));\n        } else if (id==9){\n          W[i,j] = exp(-0.5*(minuv+sqrt(u)+sqrt(v)));\n        } else if (id==10){\n          W[i,j] = log(1+0.5*maxuv);\n        }\n      }\n    }\n  }\n\n  # return W\n  return(W)\n}\n",
    "created" : 1510082194632.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3727520277",
    "id" : "51FE0945",
    "lastKnownWriteTime" : 1510082259,
    "last_content_update" : 1510082259080,
    "path" : "~/Desktop/graphon/R/auxiliary.R",
    "project_path" : "R/auxiliary.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}