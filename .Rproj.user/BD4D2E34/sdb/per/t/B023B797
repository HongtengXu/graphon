{
    "collab_server" : "",
    "contents" : "#' Estimate graphons based on Stochastic Blockmodel approximation\n#'\n#' \\code{est.SBA} takes a 2-stage approach for estimating graphons\n#' based on exchangeable random graph models. First, it finds a\n#' Stochastic Blockmodel Approximation (SBA) of the graphon. Then,\n#' it uses clustering information to estimate graphon using a consistent\n#'  histogram estimator.\n#'\n#' @param A either \\describe{\n#' \\item{Case 1.}{an \\code{(n-by-n)} binary adjacency matrix, or}\n#' \\item{Case 2.}{a vector containing multiple of \\code{(n-by-n)} binary adjacency matrices.}\n#' }\n#' @param delta a precision parameter larger than 0.\n#'\n#' @return a named list containing\n#' \\describe{\n#' \\item{H}{a \\code{(K-by-K)} matrix fo 3D histogram.}\n#' \\item{P}{an \\code{(n-by-n)} corresponding probability matrix.}\n#' \\item{B}{a length-\\code{K} list where each element is a vector of nodes/indices\n#' for each cluster.}\n#' }\n#'\n#' @examples\n#' ## generate a graphon of type No.6 with 3 clusters\n#' W = gmodel.preset(3,id=6)\n#'\n#' ## create a probability matrix for 100 nodes\n#' graphW = gmodel.block(W,n=100)\n#' P = graphW$P\n#'\n#' ## draw 17 observations from a given probability matrix\n#' A = gmodel.P(P,rep=17)\n#'\n#' ## run SBA algorithm with different deltas (0.2,0.5,0.8)\n#' res2 = est.SBA(A,delta=0.2)\n#' res3 = est.SBA(A,delta=0.5)\n#' res4 = est.SBA(A,delta=0.8)\n#'\n#' ## compare true probability matrix and estimated ones\n#' par(mfrow=c(1,4))\n#' image(P); title(\"original P\")\n#' image(res2$P); title(\"SBA with delta=0.2\")\n#' image(res3$P); title(\"SBA with delta=0.5\")\n#' image(res4$P); title(\"SBA with delta=0.8\")\n#'\n#' @references Airoldi, E.M., Costa, T.B., and Chan, S.H. (2013) \\emph{Stochastic\n#' blockmodel approximation of a graphon: Theory and consistent estimation}. Advances\n#' in Neural Information Processing Systems,  692-700.\n#' @references Chan, S.H. and Airoldi, E.M. (2014) \\emph{A consistent histogram\n#' estimator for exchangeable graph models}. Journal of Machine Learning Research Workshop\n#' and Conference Proceedings, Vol.32, No.1:208-216.\n#'\n#' @seealso \\code{\\link{est.LG}}\n#' @export\nest.SBA <- function(A,delta=0.5){\n  ## Preprocessing : Directed Allowed\n  if (is.vector(A)&&is.list(A)){\n    if (!is.binAdjvec(A,sym=FALSE)){\n      stop(\"* est.SBA : input matrix or vector A is invalid.\")\n    }\n    vecA = A\n  } else {\n    if (!is.binAdj(A,sym=FALSE)){\n      stop(\"* est.SBA : input matrix A is invalid.\")\n    }\n    vecA = vector(\"list\")\n    vecA[[1]] = A\n  }\n  ## Preprocessing : delta\n  if (delta<=0){\n    stop(\"* est.SBA : delta should be a positive number.\")\n  }\n\n  ## Main Estimation\n  # 1. parameters\n  nT = length(vecA)    # number of random graphs\n  n  = nrow(vecA[[1]]) # number of nodes\n  B  = vector(\"list\")  # empty block labels\n\n  PivotIdx = sample(1:n,1) # initial pivot index\n  B[[1]]   = PivotIdx      # Block 1 should contain Pivot 1\n\n  NotAssignedVector = rep(TRUE,n)\n  NotAssignedVector[PivotIdx] = FALSE\n  NotAssignedIdx = which(NotAssignedVector)\n\n  # 2. main iteration\n  #   loops until\n  #   - all indices have been assigned\n  #   - all nodes have been scanned\n  while (any(NotAssignedVector==TRUE)){\n    # 2-1. randomly choose a vectex from Omega\n    if (length(NotAssignedIdx)>1){\n      i = sample(NotAssignedIdx,1)\n    } else {\n      i = NotAssignedIdx\n    }\n    NotAssignedVector[i] = FALSE\n    NotAssignedIdx = which(NotAssignedVector)\n\n    # 2-2. Compute the distance estimate d\n    dhat = array(0,c(length(PivotIdx),1))\n    for (j in 1:length(PivotIdx)){\n      # define the j-th pivot\n      bj = PivotIdx[j]\n\n      # define the set S (nbd for computing dhat)\n      SVector = (!logical(length=n))\n      SVector[c(i,bj)] = FALSE\n      SIdx = which(SVector)\n\n      # compute dhat using formula (5) in SBA paper\n      Tf = floor((nT+1)/2)\n      if (Tf<nT){\n        Term1 = sum(((1/Tf)*sum3(vecA, i,SIdx,1:Tf))*((1/(nT-Tf))*sum3(vecA, i,SIdx,(Tf+1):nT)))\n        Term2 = sum(((1/Tf)*sum3(vecA,bj,SIdx,1:Tf))*((1/(nT-Tf))*sum3(vecA,bj,SIdx,(Tf+1):nT)))\n        Term3 = sum(((1/Tf)*sum3(vecA, i,SIdx,1:Tf))*((1/(nT-Tf))*sum3(vecA,bj,SIdx,(Tf+1):nT)))\n        Term4 = sum(((1/Tf)*sum3(vecA,bj,SIdx,1:Tf))*((1/(nT-Tf))*sum3(vecA,i, SIdx,(Tf+1):nT)))\n\n        Term5 = sum(((1/Tf)*sum3(vecA,SIdx, i,1:Tf))*((1/(nT-Tf))*sum3(vecA,SIdx,i, (Tf+1):nT)))\n        Term6 = sum(((1/Tf)*sum3(vecA,SIdx,bj,1:Tf))*((1/(nT-Tf))*sum3(vecA,SIdx,bj,(Tf+1):nT)))\n        Term7 = sum(((1/Tf)*sum3(vecA,SIdx, i,1:Tf))*((1/(nT-Tf))*sum3(vecA,SIdx,bj,(Tf+1):nT)))\n        Term8 = sum(((1/Tf)*sum3(vecA,SIdx,bj,1:Tf))*((1/(nT-Tf))*sum3(vecA,SIdx,i, (Tf+1):nT)))\n      } else {\n        Term1 = sum(((1/Tf)*sum3(vecA, i,SIdx,1:Tf)))\n        Term2 = sum(((1/Tf)*sum3(vecA,bj,SIdx,1:Tf)))\n        Term3 = sum(((1/Tf)*sum3(vecA, i,SIdx,1:Tf)))\n        Term4 = sum(((1/Tf)*sum3(vecA,bj,SIdx,1:Tf)))\n\n        Term5 = sum(((1/Tf)*sum3(vecA,SIdx, i,1:Tf)))\n        Term6 = sum(((1/Tf)*sum3(vecA,SIdx,bj,1:Tf)))\n        Term7 = sum(((1/Tf)*sum3(vecA,SIdx, i,1:Tf)))\n        Term8 = sum(((1/Tf)*sum3(vecA,SIdx,bj,1:Tf)))\n      }\n\n      dhatTmp = 0.5*(abs(Term1+Term2-Term3-Term4) + abs(Term5+Term6-Term7-Term8));\n      dhat[j] = sqrt(abs(dhatTmp/length(SIdx)));\n    }\n\n    # 2-3. Assign Clusters\n    Val = min(dhat)\n    Idx = which(dhat==Val)\n    if (Val<delta){\n      # If min distance < Delta, assign to one of the existing blocks\n      B[[Idx]] = c(B[[Idx]], i)\n    } else {\n      # If min distance > Delta, make a new block; Put i as pivot\n      B[[length(PivotIdx)+1]] = i\n      PivotIdx = c(PivotIdx, i)\n    }\n  }\n\n  # 3. histogram 3D\n  result = histogram3D(vecA,B)\n  result$B = B\n  return(result)\n}\n",
    "created" : 1504642713953.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3550394245",
    "id" : "B023B797",
    "lastKnownWriteTime" : 1504642264,
    "last_content_update" : 1504642264,
    "path" : "~/Desktop/ver_0.1 .1/graphon/R/est.SBA.R",
    "project_path" : "R/est.SBA.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}